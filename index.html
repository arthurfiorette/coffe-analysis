<!-- OSS page hosted at & by: https://github.com/arthurfiorette/coffee-analysis -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Transformar XLSX</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>☕</text></svg>"
    />
  </head>

  <body>
    <script
      src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"
      integrity="sha256-yVBhl8r4CaB1tt7h2g02+xnacVj/6KiOewyWxdhiPJk="
      crossorigin="anonymous"
    ></script>

    <form id="fileForm">
      <h1>Envie o arquivo XLSX para começar...</h1>
      <input
        type="file"
        name="xlsx"
        accept=".xlsx"
        id="fileInput"
        style="font-size: medium"
      />
    </form>

    <form id="sheetForm" style="display: none">
      <h1>Quais páginas devemos contabilizar?</h1>
      <div id="sheetDiv"></div>
      <br />
      <button type="submit" id="submit" style="font-size: medium">Gerar</button>
    </form>
  </body>

  <script async defer>
    // Previne que a pagina recarregue ao enviar qualquer formulário
    document
      .querySelectorAll('form')
      .forEach((form) =>
        form.addEventListener('submit', (event) => event.preventDefault())
      );
  </script>

  <script async defer>
    const fileForm = document.getElementById('fileForm');
    const fileInput = document.getElementById('fileInput');

    const sheetForm = document.getElementById('sheetForm');
    const sheetDiv = document.getElementById('sheetDiv');

    fileInput.addEventListener('change', function (e) {
      const file = e.target.files[0];
      const reader = new FileReader();

      reader.addEventListener('load', (e) => {
        const workbook = XLSX.read(e.target.result, { type: 'binary' });

        // Vai para a próxima etapa
        fileForm.style.display = 'none';
        sheetForm.style.display = 'block';
        sheetDiv.innerHTML = '';

        handleFileChosen(workbook);
      });

      reader.readAsBinaryString(file);
    });

    /**
     * Cria um elemento para selecionar todas as páginas do xlsx
     */
    function handleFileChosen(workbook) {
      for (const name of workbook.SheetNames) {
        sheetDiv.appendChild(createPageCheckbox(name));
      }

      sheetForm.addEventListener('submit', (e) => {
        e.preventDefault();

        const checks = sheetDiv.querySelectorAll('input:checked');
        const selectedSheets = Array.from(checks).map((input) => input.value);

        parseWorkbook(workbook, selectedSheets);
      });
    }

    /**
     * Cria o elemento de checkbox para selecionar as páginas necessárias
     */
    function createPageCheckbox(name) {
      const wrapper = document.createElement('div');

      wrapper.style.marginTop = '0.25rem';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.name = 'sheets[]';
      checkbox.id = name;
      checkbox.value = name;
      checkbox.checked = true;

      const label = document.createElement('label');
      label.htmlFor = name;
      label.innerText = name;

      wrapper.appendChild(checkbox);
      wrapper.appendChild(label);

      return wrapper;
    }

    /**
     * Faz o parse final somente com as páginas selecionadas
     */
    function parseWorkbook(workbook, selectedSheets) {
      const elements = new Set();

      const result = {
        Amostra: []
      };

      /** 
         * @type {[
            {
              sheetName: string;
              resultRow: Record<string, number>;
              data: [
                { 'R. Time': number; Area: number; 'Relative area (%)': number; Name: string }
              ];
            }
          ]}
        */
      const sheets = selectedSheets.map((sheetName) => {
        const worksheet = workbook.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(worksheet);

        for (const row of data) {
          // Adiciona o nome do elemento ao set único
          elements.add(row.Name);
        }

        return {
          sheetName,
          // Cria a linha para esta página, caso inexistente
          resultRow: (result[sheetName] ??= {}),
          data
        };
      });

      for (const { sheetName, data, resultRow } of sheets) {
        for (const sheetRow of data) {
          if (!sheetRow['Name']) {
            // Inclui o não informado quando tiver um elemento sem nome.
            elements.add((sheetRow['Name'] = 'Não informado'));
          }

          const elementName = sheetRow['Name'];
          const area = sheetRow['Relative area (%)'];

          if (isNaN(Number(sheetRow['R. Time']))) {
            continue;
          }

          resultRow[elementName] ??= 0;
          resultRow[elementName] += area;
        }
      }

      // Adiciona os headers em ordem alfabética
      result.Amostra.push(...Array.from(elements).sort());

      for (const elementName in result) {
        if (elementName === 'Amostra') {
          continue;
        }

        const elementRecord = result[elementName];
        result[elementName] = [];

        for (const headerName of result.Amostra) {
          result[elementName].push(elementRecord[headerName] ?? 0);
        }
      }

      // Cria o excel e o baixa
      const wb = XLSX.utils.book_new();

      // Transforma { a: [1, 2] } em [['a', 1, 2]]
      const array = Object.entries(result).map(([name, row]) => [name, ...row]);

      const ws = XLSX.utils.json_to_sheet(array, { skipHeader: true });
      XLSX.utils.book_append_sheet(wb, ws, 'Resultado');

      // Write file and then reload the page
      XLSX.writeFile(wb, 'result.xlsx', { bookType: 'xlsx' });
      window.location.reload();
    }
  </script>
</html>
